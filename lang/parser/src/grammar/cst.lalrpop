use std::rc::Rc;

use syntax::cst::*;

use super::util::span;

#[LALR]
grammar;

// Tokens
match {
    // Symbols
    "(", ")", "{", "}", ";", ":=", "=>", ",", ":", ".", "=",
    // Names
    r"[a-zA-Z_][a-zA-Z0-9_]*[']*",
    // Keywords
    "def", "codef", "data", "codata",
    "match", "comatch",
    "Type",
    "absurd",
    // Comments and whitespace
    r"\s*" => { }, // Skip whitespace
    r"--[^\n\r]*[\n\r]*" => { }, // Skip `--` comments
}

// Utils
// Based in part on Gluons grammar (https://github.com/gluon-lang/gluon/blob/fac08dcff7a019440dd8d0a886abdb18baa58198/parser/src/grammar.lalrpop)

Comma<Rule>: Vec<Rule> =
    <rules: (<Rule> ",")*> <last: Rule?> => {
        let mut rules = rules;
        rules.extend(last);
        rules
    };

Parens<Rule>: Rule =
    "(" <rule: Rule> ")" => rule;

Braces<Rule>: Rule =
    "{" <rule: Rule> "}" => rule;

ParenthesizedArgs<Rule>: Vec<Rule> = Parens<Comma<Rule>>;
OptParenthesizedArgs<Rule>: Vec<Rule> = <args: Parens<Comma<Rule>>?> => args.unwrap_or_default();

BracedArgs<Rule>: Vec<Rule> = Braces<Comma<Rule>>;
OptBracedArgs<Rule>: Vec<Rule> = <args: Braces<Comma<Rule>>?> => args.unwrap_or_default();

Param: Param = <name: Ident> ":" <typ: Exp> => Param { name, typ } ;
EqnParam : EqnParam = <name: Ident> ":" <eqn: Eqn> => EqnParam { name, eqn } ;

Params: Vec<Param> = ParenthesizedArgs<Param>;
OptParams: Vec<Param> = OptParenthesizedArgs<Param>;

EqnParams: Vec<EqnParam> = BracedArgs<EqnParam>;
OptEqnParams: Vec<EqnParam> = OptBracedArgs<EqnParam>;

Telescope: Telescope = <params: Params> => Telescope(params);
OptTelescope: Telescope = <params: OptParams> => Telescope(params);

Args: Vec<Rc<Exp>> = ParenthesizedArgs<Exp>;
OptArgs: Vec<Rc<Exp>> = OptParenthesizedArgs<Exp>;

// Program

pub Prg: Prg = {
    <decls: (<Decl> ";")*> <exp: Exp?> => Prg { decls, exp },
}

pub Decl: Decl = {
    <l: @L> "data" <name: Ident> <params: OptTelescope> ":" "Type" ":=" <ctors: Comma<Ctor>> <r: @R> => Decl::Data(Data { info: span(l, r), name, params, ctors }),
    <l: @L> "codata" <name: Ident> <params: OptTelescope> ":" "Type" ":=" <dtors: Comma<Dtor>> <r: @R> => Decl::Codata(Codata { info: span(l, r), name, params, dtors }),
    <l: @L> "def" <on_typ: TypApp> "." <name: Ident> <params: Telescope> ":" <in_typ: Exp> ":=" <body: Match> <r: @R> => Decl::Def(Def { info: span(l, r), name, params, on_typ, in_typ, body }),
    <l: @L> "codef" <name: Ident> <params: Telescope> ":" <typ: TypApp> ":=" <body: Comatch> <r: @R> => Decl::Codef(Codef { info: span(l, r), name, params, typ, body }),
}

Ctor: Ctor = {
    <l: @L> <name: Ident> <params: OptTelescope> ":" <typ: TypApp> <r: @R> => Ctor { info: span(l, r), name, params, typ },
}

Dtor: Dtor = {
    <l: @L> <on_typ: TypApp> "." <name: Ident> <params: OptTelescope> ":" <in_typ: Exp> <r: @R> => Dtor { info: span(l, r), name, params, on_typ, in_typ },
}

pub Comatch : Comatch = {
    <l: @L> "comatch" <cases: Comma<Cocase>> <r: @R> => Comatch { info: span(l, r), cases },
}

pub Match : Match = {
    <l: @L> "match" <cases: Comma<Case>> <r: @R> => Match { info: span(l, r), cases },
}

pub Case : Case = {
    <l: @L> <name: Ident> <args: OptTelescope> <eqns: OptEqnParams> <body: AbsurdOrBody> <r: @R> => Case { info: span(l, r), name, args, eqns, body },
}

pub Cocase : Cocase = {
    <l: @L> <name: Ident> <args: OptTelescope> <eqns: OptEqnParams> <body: AbsurdOrBody> <r: @R> => Cocase { info: span(l, r), name, args, eqns, body },
}

pub AbsurdOrBody: Option<Rc<Exp>> = {
    "absurd" => None,
    "=>" <body: Exp> => Some(body),
}

pub TypApp: TypApp = {
    <l: @L> <name: Ident> <args: OptArgs> <r: @R> => TypApp { info: span(l, r), name, args },
}

pub Eqn: Eqn = {
    <l: @L> <lhs: Exp> "=" <rhs: Exp> <r: @R> => Eqn { info: span(l, r), lhs, rhs }
}

pub Exp: Rc<Exp> = {
    <l: @L> <exp: Ops> ":" <typ: Exp> <r: @R> => Rc::new(Exp::Anno { info: span(l, r), exp, typ }),
    Ops,
}

pub Ops = {
    <l: @L> <exp: Ops> "." <name: Ident> <args: Args> <r: @R> => Rc::new(Exp::DotCall { info: span(l, r), exp, name, args }),
    App,
}

pub App = {
    <l: @L> <name: Ident> <args: Args> <r: @R> => Rc::new(Exp::Call { info: span(l, r), name, args }),
    Builtins,
}

pub Builtins: Rc<Exp> = {
    <l: @L>"Type" <r: @R> => Rc::new(Exp::Type { info: span(l, r) }),
    Atom,
}

pub Atom: Rc<Exp> = {
    "(" <exp: Exp> ")" => exp,
    <l: @L> <name: Ident> <r: @R> => Rc::new(Exp::Call { info: span(l, r), name, args: Args::new() }),
}

// Names
Ident: String = <s:r"[a-zA-Z_][a-zA-Z0-9_]*[']*"> => s.to_owned();
