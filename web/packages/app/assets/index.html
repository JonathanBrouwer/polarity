<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@1.*/css/pico.min.css">
  <script type="text/javascript">
    function jumpToHash(x) {
      location.hash=x;
    }
  </script>
  <title>Proof Expression Problem</title>
</head>

<body>
  <header class="container">
    <h1>The Proof Expression Problem</h1>

    <details role="list">
      <summary aria-haspopup="listbox">Examples</summary>
      <ul role="listbox">
        <li><a onclick="jumpToHash('stlc.xfn')" >stlc.xfn</a></li>
        <li><a onclick="jumpToHash('arith.xfn')">arith.xfn</a></li>
        <li><a onclick="jumpToHash('boolrep.xfn')">boolrep.xfn</a></li>
      </ul>
    </details>
  </header>
  <main class="container">
    <!-- Editor -->
    <section class="content">
      <div class="editor-container">
        <div id="editor" style="height: 1000px"></div>
      </div>
    </section>
    <!-- Tutorial -->
    <section id="tutorial">
      <h5>Tutorial</h5>

      This is a short overview of the syntax of our language.
      
      <h6>Data Types</h6>

      The simplest form of datatypes do not have parameters or indizes.
      In that case, the constructors of the data-type can be given as a comma-separated list.
      As with all syntactic constructs, we always allow trailing commas.

<pre><code>
data Bool { True, False, }
</code></pre>

      In the more general case we have to specify the precise type that a constructor constructs.
      Therefore, the above data type declaration can be written more explicitly as:
      
<pre><code>
data Bool { True: Bool, False: Bool }
</code></pre>
      
      A simple example of a parameterized type is the type of singly-linked lists of some type <code>a</code>.
      In that case, we have to specify both the parameters of the type constructor <code>List</code>, and the instantiations of the term constructors <code>Nil</code> and <code>Cons</code>.
      For the parameter of the type constructor <code>List</code> we make use of the impredicative type universe, which is written <code>Type</code>.
<pre><code>
data List(a: Type) {
  Nil(a: Type): List(a),
  Cons(a: Type, x: a, xs: List(a)): List(a)
}
</code></pre>

A proper dependent type is the type of length-indexed lists: the vector type.
The <code>VNil</code> and <code>VCons</code> constructors of vectors create vectors with different indizes.
<pre><code>
data N { Z, S(n: N) }
data Vec(a: Type, n: Nat) {
  VNil(a:Type): Vec(a,Z),
  VCons(a: Type, n: N, x: a, xs: Vec(a,n)): Vec(a,S(n))
}
</code></pre>
      <h6>Codata Types</h6>
      Codata types are specified by a list of methods or destructors.
      A very simple example is the type of pairs of a boolean and a natural number:
<pre><code>
data Bool { True, False }
data N { Z, S(n: N)}
codata Pair {
  proj1: Bool,
  proj2: N,
}
</code></pre>
      This type supports two observations; the first observations <code>proj1</code> yields a boolean value when invoked on a <code>Pair</code>, and the observation <code>proj2</code> yields a natural number.
      
      Codata types can also model infinite types. The type of infinite streams is a classical example and written like this:
<pre><code>
codata Stream(a: Type) {
  Stream(a).head(a: Type) : a,
  Stream(a).tail(a: Type) : Stream(a),
}
</code></pre>
       Sometimes we also need to reference the object on which a method is invoked in its return type.
       This is especially the case when we want an observation to yield a proof that the object satisfies some property.
       Here is a simple example which shows how this can be expressed:
<pre><code>
codata Bool {
  Bool.neg : Bool
  (x: Bool).neg_is_inverse : Eq(Bool, x, x.neg.neg)
}
</code></pre>


      <h6>Definitions</h6>

      <h6>Codefinitions</h6>

      <h6>Comments</h6>

      Line comments are written using two dashes: <code>-- This is a comment</code>.
      Certain items of the program can also be annotated with a documentation comment.
      Here is an example using doc-comments:
<pre><code>
-- | The type of booleans
data Bool {
  -- | The boolean truth value
  True,
  -- | The boolean false value
  False,
}
</code></pre>
      These documentation comments are preserved during defunctionalization and refunctionalization.

      <h6>Typed Holes</h6>

      An incomplete program can be written using typed holes.
      Typed holes are written using either <code>?</code> or <code>...</code>; they have type <code>?</code> which unifies with any other type.
      For example, an incomplete implementation of boolean negation can be written as follows:
<pre><code>
def Bool.neg : Bool {
  True => ?,
  False => ?,
}          
</code></pre>

      <h6>The Main Expression</h6>

      After all other data types, codata types, definitions and codefinitions an additional expression can be written.
      This is called the "main" expression of the program.
<pre><code>
data Bool { True, False }
def Bool.neg {
  True => False,
  False => True,
}
True.neg
</code></pre>
    </section>
    <!-- Debug Output -->
    <section id="accordions">
      <h5>Debug Output</h5>
      <details>
        <summary>Console</summary>
          <textarea id="channel-console" autocomplete="off" spellcheck="off" wrap="off" readonly rows="3"></textarea>
      </details>
      <details>
        <summary>Client To Server</summary>
          <textarea id="channel-client" autocomplete="off" spellcheck="off" wrap="off" readonly rows="4"></textarea>
      </details>
      <details>
        <summary>Server To Client</summary>
          <textarea id="channel-server" autocomplete="off" spellcheck="off" wrap="off" readonly rows="4"></textarea>
      </details>
    </section>
  </main>
  <footer class="container">
    Copyright(2023)
  </footer>
</body>

</html>